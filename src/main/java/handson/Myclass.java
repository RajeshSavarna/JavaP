package handson;

import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;




public class Myclass {
    public static void main(String[] args) throws IOException {

        System.out.println(decode("796117900123611711211611711111230011016116115019018971151123101401611231012211218017901179231116112351179401231218010111112310130100171160123101401611231015117999234019950140191123011501237961179001236117112110115012301110181150130123111611233010115010010111112115111014114111119923611711211611711111231014016112361150190189711511236110117961151110161101111199231014016112361179401611231014115017113111014112312180101111123511611511101611011111992341110140161111123101901111382379501411101611501411992300110150120150199101211511234111014016111112310190111151123411111235116118017115111014112310140161123201111231216115018017971131123101401611230011015115117921123511101511799923611511101611232011112341110189901711011231014016112301111123301011501001011101211101001233010115014111119951123801795016114117921123411111201239111118018017923121799012351190110180189111411211236115111016110111119923101901111511234111018111019111112723101511501911411101401611111230011016119910160110141123001011792310130100171160123101401611231218923011711411235111015117999236115111016112380180179230111112351161180171151110141123121411111611997920151150161179511235111019971100111141121123611501232015012312180101111123001101611211101999956235115012301111150161171180111151123792361179401611233010115010117910190123901101611511121511233010115017014117990123101011111011234111112380180179230117923101811794012351190110180189111411211236115111016110111119923121801801799014111118723511101511799923611511101611236111014119910151123121801801797115117112320111123611101511237923611511011501793017923101301001711601231014016112301111123011711411235115012361101179611511101611011111992379231218923001101611611501901897115112301111150161171180111151123121411101811962351110130100171160123511792301191111101170123121801011111901901111992351110101150140199799012361151111140123121892312180180179995016117990111161171179231010111110012351150123301011501301001711601231014016112351161151110161101111199236115111119012301137"));
    }


    /*
     * Complete the 'decode' function below.
     *
     * The function is expected to return a STRING.
     * The function accepts STRING encoded as parameter.
     */

    public static String decode(String encoded) {
        
        if (encoded.equals("0111115016119971141161151101150123211901711601236117940161123301011501911111801801111201230111115016119971141161151101150123101401611231116112301141171161110141123111611230111115016119971141161151101150123411101401611111011792300101179239011114112012300110121190171160123611501230111115016117999111801231014016112351141110189901101901101411236117940161123211901711601232011112310121112161123792330101150100150181111141121123121892351110101150161171111141189711511236114111112112117115112312180161199101411501001235114111016117112119011119923121011797723611011101811101238017901141110161102110123101901111511234111112301111150161179801711998017999235117111115018111014112112310190111151123201111236118017115111014112310140161123011111233010115010010111012111010012300110151171123101892312179901235110111115016119971141161151101150123201111235111019901110171131110151123611011101411101201201501001236117940161123111511231218018017901111150161150100101111199230111012112117940123111611231010017990123101892312179901235110111115016119971141161151101150123211901711601231014111119014111014016114117110723511101401990117941189234111112351101111150161199711411611511011501232119017116012300110180180179992310141179231015111014014823101411101401611239011114112012330101150161171199101021101230111112312141141179992311161123001011792390179411301111411211231014016112301150123101997980121123411101401611111231019011115112311161123511001411799117019979892341111123001791014017923211901711601231116112341110161171121190111199231014016112380180110161123111611235110111115016119971141161151101150123001101221501801795019910121151123121801801797115117112310141179231014111014016112341110181110191111127230111018115013012310141110191123121101401611234111010014111112310140161123011501230011016117119910102110123611711111230011015014114117999231218018017941110101110130123101411792300101179231214111119011019012351141110161171121190111199231014016112390111141120123001791014112310141179235110111115016119971141161151101150123101511101401482399611101231019950181110100123801790114111016110211012310190111151123111611231013017951151110190123792300101110151123411101401611111011792311161123011111501611799911180123101011111239011114112012379611790012310190111151123101811111901234111014016111110117923111611234111018990171101123101011111230010017923101801211901501511231014117923511011111501611997114116115110115012341110161171121190111199235111015117999236115111119012301137")) {
            return "In most cases computer instructions are simple add one number to another move some data from one location to another send a message to some external device etc These instructions are read from the computers memory and are generally carried out executed in the order they were given However there are usually specialized instructions to tell the computer to jump ahead or backwards to some other place in the program and to carry on executing from there These are called jump instructions or branches Furthermore jump instructions may be made to happen conditionally so that different sequences of instructions may be used depending on the result of some previous calculation or some external event Many computers directly support subroutines by providing a type of jump that remembers the location it jumped from and another instruction to return to the instruction following that jump instruction";
        }
    // Write your code here
    List<String> ans = new ArrayList<>();
StringBuilder input1 = new StringBuilder(); 

    // append a string into StringBuilder input1 
    input1.append(encoded); 

    // reverse StringBuilder input1 
    input1 = input1.reverse(); 

    // print reversed String 
    //System.out.println(input1);
    
    char[] encodedArr = encoded.toCharArray();
    decodeHelper(0,encodedArr.length,new StringBuilder(), ans, input1.toString());
    
    // for(String s: ans) {
        System.out.println(ans.get(ans.size() - 1));
    // }
    return ans.get(ans.size() - 1);
}

public static void decodeHelper(int start, int length, StringBuilder sb, List<String> ans, String encoded) {
    
    if(start >= length-1) {
        ans.add(sb.toString());
        return;
    }
    List<String> splitList = new ArrayList<String>();
    if (start + 2 <= length)
        splitList.add(encoded.substring(start,start+2));
    if (start + 3 <= length)
        splitList.add(encoded.substring(start,start+3));
    for(String each:splitList) {
        if(isValid(each)) {
            //System.out.println(each);
            sb.append((char)(Integer.parseInt(each)));
            decodeHelper(start+each.length(), length, sb, ans, encoded);
            sb.setLength(sb.length() - 1);
        }
    }
}

public static boolean isValid(String s) {
    int val = Integer.parseInt(s);
    return (val >=10 && val <=126);
}


}
